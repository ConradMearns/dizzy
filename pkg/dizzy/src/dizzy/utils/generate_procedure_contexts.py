#!/usr/bin/env python3

"""
Generate ProcedureContext classes from procedures.d.yaml.

This utility reads the procedure definitions and generates Python dataclasses
for procedure contexts with nested emit and query attributes.
"""

import yaml
from pathlib import Path
from typing import Dict


def parse_procedures_yaml(yaml_path: Path) -> Dict:
    with open(yaml_path) as f:
        return yaml.safe_load(f)


def generate_context_classes(
    procedures: Dict,
    output_path: Path,
    events_import_path: str = 'gen.events',
    queries_import_path: str = 'gen.queries'
):
    """Generate ProcedureContext classes."""

    lines = [
        '"""',
        'Auto-generated ProcedureContext classes.',
        '',
        'DO NOT EDIT THIS FILE MANUALLY.',
        'Generated from procedures.d.yaml by dizzy.utils.generate_procedure_contexts',
        '"""',
        '',
        'from dataclasses import dataclass',
        'from typing import Callable',
        '',
        '# Import event types',
        f'from {events_import_path} import (',
    ]

    # Collect all unique event types from emitters
    event_types = set()
    for proc_name, proc_def in procedures.items():
        if 'emitters' in proc_def:
            for event_type in proc_def['emitters'].values():
                event_types.add(event_type)

    for event_type in sorted(event_types):
        lines.append(f'    {event_type},')
    lines.append(')')
    lines.append('')

    # Import query types
    lines.append('# Import query types')
    lines.append(f'from {queries_import_path} import (')

    query_types = set()
    for proc_name, proc_def in procedures.items():
        if 'queries' in proc_def:
            for query_type in proc_def['queries'].values():
                query_types.add(query_type)
                # Also need the Input type
                query_types.add(f'{query_type}Input')

    for query_type in sorted(query_types):
        lines.append(f'    {query_type},')
    lines.append(')')
    lines.append('')
    lines.append('')

    # Generate classes for each procedure
    for proc_name, proc_def in procedures.items():
        # Generate Emitters class
        emitters_class = f'{proc_name}Emitters'
        lines.append(f'@dataclass')
        lines.append(f'class {emitters_class}:')
        lines.append(f'    """Emitters for {proc_name} procedure."""')

        if 'emitters' in proc_def and proc_def['emitters']:
            for emit_name, event_type in proc_def['emitters'].items():
                # Remove 'emit_' prefix if present
                attr_name = emit_name.replace('emit_', '')
                lines.append(f'    {attr_name}: Callable[[{event_type}], None]')
        else:
            lines.append('    pass')

        lines.append('')
        lines.append('')

        # Generate Queries class
        queries_class = f'{proc_name}Queries'
        lines.append(f'@dataclass')
        lines.append(f'class {queries_class}:')
        lines.append(f'    """Queries for {proc_name} procedure."""')

        if 'queries' in proc_def and proc_def['queries']:
            for query_name, query_type in proc_def['queries'].items():
                lines.append(f'    {query_name}: Callable[[{query_type}Input], {query_type}]')
        else:
            lines.append('    pass')

        lines.append('')
        lines.append('')

        # Generate Context class
        context_class = f'{proc_name}Context'
        lines.append(f'@dataclass')
        lines.append(f'class {context_class}:')
        lines.append(f'    """Context for {proc_name} procedure."""')
        lines.append(f'    emit: {emitters_class}')
        lines.append(f'    query: {queries_class}')
        lines.append('')
        lines.append('')

    # Write to file
    output_path.parent.mkdir(parents=True, exist_ok=True)
    with open(output_path, 'w') as f:
        f.write('\n'.join(lines))

    print(f"Generated procedure contexts: {output_path}")
    print(f"Found {len(procedures)} procedures:")
    for proc_name in procedures:
        print(f"  - {proc_name}Context")


def generate_protocol_interfaces(
    procedures: Dict,
    output_path: Path,
    procedures_import_path: str = 'gen.procedures',
    commands_import_path: str = 'gen.commands'
):
    """Generate Protocol interfaces for procedures."""

    lines = [
        '"""',
        'Auto-generated Protocol interfaces for procedure implementations.',
        '',
        'DO NOT EDIT THIS FILE MANUALLY.',
        'Generated from procedures.d.yaml by dizzy.utils.generate_procedure_contexts',
        '"""',
        '',
        'from typing import Protocol',
        f'from {procedures_import_path} import (',
    ]

    # Import all context classes and command types
    imports = []
    for proc_name in procedures:
        imports.append(f'    {proc_name}Context,')

    lines.extend(imports)
    lines.append(')')
    lines.append('')

    # Import command types
    lines.append(f'from {commands_import_path} import (')
    for proc_name in procedures:
        lines.append(f'    {proc_name}Command,')
    lines.append(')')
    lines.append('')
    lines.append('')

    # Generate Protocol for each procedure
    for proc_name in procedures:
        protocol_name = f'{proc_name}ProcedureProtocol'
        lines.append(f'class {protocol_name}(Protocol):')
        lines.append(f'    """Protocol for {proc_name} procedure implementations."""')
        lines.append(f'    ')
        lines.append(f'    def __call__(self, context: {proc_name}Context, command: {proc_name}Command) -> None:')
        lines.append(f'        """Execute the {proc_name} procedure."""')
        lines.append(f'        ...')
        lines.append('')
        lines.append('')

    # Write to file
    output_path.parent.mkdir(parents=True, exist_ok=True)
    with open(output_path, 'w') as f:
        f.write('\n'.join(lines))

    print(f"Generated procedure protocols: {output_path}")
    print(f"Found {len(procedures)} procedure protocols:")
    for proc_name in procedures:
        print(f"  - {proc_name}ProcedureProtocol")


def generate_procedure_contexts(
    procedures_yaml: Path,
    contexts_file: Path,
    protocols_file: Path,
    events_import_path: str = 'gen.events',
    queries_import_path: str = 'gen.queries',
    procedures_import_path: str = 'gen.procedures',
    commands_import_path: str = 'gen.commands'
):
    """
    Generate procedure context classes and protocol interfaces.

    Args:
        procedures_yaml: Path to procedures.d.yaml schema file
        contexts_file: Path where procedure context classes should be written
        protocols_file: Path where procedure protocol interfaces should be written
        events_import_path: Python import path for generated event models
        queries_import_path: Python import path for generated query models
        procedures_import_path: Python import path for generated procedure contexts
        commands_import_path: Python import path for generated command models
    """
    data = parse_procedures_yaml(procedures_yaml)
    procedures = data.get('procedures', {})

    generate_context_classes(
        procedures,
        contexts_file,
        events_import_path,
        queries_import_path
    )

    generate_protocol_interfaces(
        procedures,
        protocols_file,
        procedures_import_path,
        commands_import_path
    )


def main():
    """CLI entry point when run as script."""
    import sys

    if len(sys.argv) < 4:
        print("Usage: python -m dizzy.utils.generate_procedure_contexts <procedures.yaml> <contexts.py> <protocols.py>")
        sys.exit(1)

    procedures_yaml = Path(sys.argv[1])
    contexts_file = Path(sys.argv[2])
    protocols_file = Path(sys.argv[3])

    generate_procedure_contexts(
        procedures_yaml,
        contexts_file,
        protocols_file
    )


if __name__ == '__main__':
    main()
