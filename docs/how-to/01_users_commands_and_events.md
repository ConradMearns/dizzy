# Users

- Define the users of the application. Start with "Personas" like "Social Media Influencer" or roles like "Inspector"
- What do these users react to? What do these users command the system to do for them?
- Start vague and slowly increase specificity.
    - I like to make a Generic (TODO Event Storming Note Types) note that describes an "activity" when I can't think of specific enough commands yet.
    - "Driving" is an activity in which a user executes many commands asyncronously. Turning, accelerating, hadjusting volume, all seem like continuous actions that can't be modelled - but if we adjust our frame of time we can easily model each interaction on incredibly tiny time scales.
    - A CPU recording volume updates isn't going to capture the infinite detail of a rotation - it'll capture increments.
- I recommend making a table of roles, personas, and stakeholders just as you would in BIM.
    - When discussing domain or implementation, you should be ab,le to argue for or against details from the persepective of these users.

## Example User Table

| User Type | Use Case | Likelihood Score (1-10) | Rationale |
|-----------|----------|-------------------------|-----------|
| **Privacy Advocates** | Complete data sovereignty, no corporate surveillance | **9/10** | High motivation for privacy, willing to sacrifice convenience |
| **Tech Enthusiasts/Early Adopters** | Cutting-edge technology experimentation | **8/10** | Love new tech, have technical skills to set up |
| **Scientists/Researchers** | Share large datasets without AWS costs, collaborative research | **7/10** | Cost savings + data control appealing, but need reliability |
| **Content Creators (Independent)** | Own their content, avoid platform lock-in | **6/10** | Value ownership but need audience reach |
| **Small Creative Teams** | Collaborative file sharing without subscription costs | **7/10** | Cost-effective for small budgets, team control |
| **Photographers** | Portfolio management, client sharing, backup redundancy | **8/10** | High storage needs, value backup redundancy |
| **Families** | Photo sharing, family memories backup | **5/10** | Great concept but setup complexity may deter |
| **Influencers** | Content distribution, audience engagement | **3/10** | Need massive reach, platform algorithms crucial |
| **Journalists** | Secure source protection, censorship resistance | **8/10** | High value for security and decentralization |
| **Gamers** | Game saves, mods, community content sharing | **6/10** | Tech-savvy but convenience often wins |
| **Students** | Academic file sharing, group projects | **4/10** | Limited resources, prefer free existing solutions |
| **Remote Workers** | Team collaboration, file synchronization | **5/10** | Need reliability over innovation for work |
| **Activists** | Censorship-resistant communication and storage | **9/10** | Critical need for decentralized, secure storage |
| **Open Source Communities** | Distributed project hosting, community-owned infrastructure | **8/10** | Aligns with philosophical values |
| **Preppers/Survivalists** | Infrastructure independence, disaster-resistant storage | **7/10** | Values self-reliance but may lack technical skills |

This table was generated by and for an LLM. Columns in this table may not be necessariy for you, but I recommend a User Type or Role and Use Case. 

# Commands

- Determine the commands initiated against the system, simple names are all you need to start.
- Ephemeral, fire and forget

# Events

- Should contain an entity ID
- Idempotent
- Only the information required to convey change

# Procedures

<!-- Rename input -> ProcedureContext -->

Procedures are just functions that are triggered by commands.
They emit events to communicate with the larger system.

Procedures are where things start to get a little complex.
Most of the focus of the design and architecture falls on this as the primary block of action.

A procedure is just a function - it can't have any long term state.
Any long term state must instead be built into the input object - which so far is the most complex type.

<!-- TODO the input object / emitter -->
The input object might be a dumping ground for all sorts of other features I fear.
It's maybe possible to split it apart - not sure what's best yet.

It's best to imagine the time-scopes as the main determinator for seperating the arguements.

For instance, the command is expected to be unique between every single run of the procedure.
The command is what triggers the procedure afetr all -
The Input object on the other hand, is expected to change only when architecture changes.

A command be be fairly minimal, even just a keyword with no scalar data within.

Here's an example of an Input object as a dataclass.

```python
@dataclass
class ExampleProcedureContext:
    emit: Emitter[ExampleEvent]
```

<!-- TODO my type annotation here might be wrongs -->

The thing to observe here is that the ExampleProcedureContext has another constuct called an Emitter.
An Emitter is just another function.
Emitters are the primary way to return values after the procedure is finished,
and the only way they can do this is to return an object of the Event type.


```python
def example_procedure(
    command: ExampleCommand,
    context: ExampleProcedureContext,
):
    # do some work
    # return a fact that records the work we did :)
    context.emit(Event(...))
```

The desiciion to include the Emitter inside a Context object allows for slightly easier (hopefully) refactoring later,
as the domain changes, and concerns change, we may discover we have missed some details (or are finally ready to implement them)

Or, we may want to include non-domain activities that are still really important for maintenence.

Here's a slightly more complex example:


```python
@dataclass
class ExampleProcedureContext:
    emit_done: Emitter[ExampleDoneEvent]
    emit_piece: Emitter[ExamplePieceEvent]
    telemetry: Telemetry

def example_procedure(
    command: ExampleCommand,
    context: ExampleProcedureContext,
):
    for piece in context.telemetry.tqdm(pieces):
        context.emit_done(ExamplePieceEvent(...))

    context.emit_done(ExampleDoneEvent(...))
```


# Policy

Policies are very similar to Procedures, but they activate on Events and issue Commands instead

```python
@dataclass
class ExamplePolicyContext:
    issue: Issuer[ExampleCommand]

def example_policy(
    event: ExampleEvent,
    context: ExamplePolicyContext,
):
    context.issue(ExampleCommand(...))
```

# Conclusion

Should now understand

- Events
- Commands
- Procedures
- Policies
- Context
- Emitters and Issuers