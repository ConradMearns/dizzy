{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"getting dizzy","text":"<p>\u201cStart Where You Are. Use What You Have. Do What You Can.\u201d - Arthur Ashe</p> <p>There isn't one particular goal with this project, this repository is meant to serve as a piece of living proof of failure and progress.</p> <p>We are engine building - bootstrapping a paradigm for processing that can survive shifting paradigms, requirements, domains, whim and fancy alike. It is the bastard child of many problems:</p> <ul> <li> <p>Contract work typically demands a new bespoke system be created every 1-3 years. This is fun - but not sustainable. What if we could carry over the largest least-interesting piece of technology every time to provide a backbone for developing and exploring new paradigms instead of re-inventing the wheel every time?</p> </li> <li> <p>Questions of which database are best suited for the user, what UI JS frontend is coolest, what programming language is most likely to provide job stability are tired. It should not matter what of these decisions we make now, because we are more likely to be wrong than right anyway. Therefor - we would be better equipped for these questions if we had an architecture that granted us the grace of making these mistakes and correcting them - rather than living with the pain of our ignorance forever.</p> </li> </ul> <p>Besides these burning problems - we also have a general burning desire that we share. Surely some things could be better.</p> <p>The architecture we build here is intended not to be the best - but to be as flexible as possible to the point we know longer care about what's best.</p>"},{"location":"#what-the-heck-is-this-for","title":"What the heck is this for","text":"<ul> <li>Running pipelines that can be resumed later<ul> <li>Let me write a quick script that will never be used for production workflows real quick...</li> </ul> </li> <li>Replacing Jupyter as a scientific processing tool to accelerate TRL<ul> <li>DAG's are everywhere and in-memory objects are not to be trusted</li> </ul> </li> <li>Meta-programming without DSL's or Monkey-patching<ul> <li>cool IaC bro, can I have a diagram?</li> </ul> </li> <li>The MO - Moving Objects<ul> <li>hey can you send me those vacation photos of me? thx &lt;3</li> </ul> </li> <li>???<ul> <li>do u got games on ur phone</li> </ul> </li> </ul> <p>Links</p> <ul> <li>Build your own event system in Python</li> <li>Building Efficient Event-Driven ETL Processes on Google Cloud: Best Practices, Correlation ID Tracking and Testing</li> <li>Mentat</li> <li>https://www.cosmicpython.com/blog/2017-09-19-why-use-domain-events.html</li> <li>https://www.cosmicpython.com/</li> <li>https://blog.jannikwempe.com/domain-driven-design-entities-value-objects</li> <li>https://ogrady.github.io/jekyll/update/2021/12/17/entity-component-system.html</li> </ul> <p>Links - less relevant</p> <ul> <li>Rust's trait system is a proof engine, let's make it prove us an ABI! - Pierre Avital</li> </ul>"},{"location":"reference/","title":"Reference","text":"<ul> <li>Commands (intent)</li> <li>Procedures (pure business logic)</li> <li>Events (immutable facts)</li> <li>Policies (reconciliation logic)</li> <li>Queries (read operations)</li> <li>Mutations (write operations)</li> </ul>"},{"location":"reference/#events","title":"Events","text":"<ul> <li>Must described in past-tense</li> <li>Must be Immutable</li> <li>Should be self contained (all data required for representing some model state is contained in events)</li> <li>Ordered</li> </ul>"},{"location":"reference/#commands","title":"Commands","text":"<ul> <li>Represent an intention or request to perform an action</li> <li>MUST be serializable (JSON, YAML, etc.)</li> <li>MUST be immutable</li> <li>Named in imperative form (e.g., <code>ScanPartition</code>, <code>InspectStorage</code>)</li> <li>MUST NOT contain business logic or behavior</li> <li>Self-contained with all required data for execution</li> </ul>"},{"location":"reference/#procedures","title":"Procedures","text":"<ul> <li>Consume Commands</li> <li>CAN emit Events</li> <li>CAN query state (read-only)</li> <li>MUST NOT mutate state</li> <li>Have signature: <code>(context: ProcedureContext, command: Command) -&gt; None</code></li> <li>Stateless (all state via context or command)</li> <li>Contain business logic for processing commands</li> </ul>"},{"location":"reference/#policies","title":"Policies","text":"<ul> <li>Consume Events</li> <li>CAN emit Commands</li> <li>CAN query state (read-only)</li> <li>CAN mutate state (via mutations)</li> <li>Have signature: <code>(context: PolicyContext, event: Event) -&gt; None</code></li> <li>Stateless (all state via context or event)</li> <li>Contain business logic for reacting to events</li> </ul>"},{"location":"reference/#models","title":"Models","text":""},{"location":"reference/#queriers","title":"Queriers","text":"<ul> <li>Perform read-only operations</li> <li>MUST NOT mutate state</li> <li>MUST NOT emit events or commands</li> <li>Have signature: <code>(input: QueryInput) -&gt; QueryResult</code></li> <li>Deterministic when possible</li> <li>CAN access external systems (databases, filesystems, APIs)</li> <li>Return serializable data structures</li> </ul>"},{"location":"reference/#mutators","title":"Mutators","text":"<ul> <li>Perform write operations</li> <li>CAN mutate state (event store, databases, filesystems, etc.)</li> <li>MUST NOT emit events or commands directly</li> <li>Have signature: <code>(input: MutationInput) -&gt; MutationResult</code></li> <li>Idempotent when possible</li> <li>CAN have side effects</li> <li>Return confirmation or status of the mutation</li> </ul>"},{"location":"reference/commands/","title":"Commands","text":"<ul> <li>Represent an intention or request to perform an action</li> <li>MUST be serializable (JSON, YAML, etc.)</li> <li>MUST be immutable</li> <li>Named in imperative form (e.g., <code>ScanPartition</code>, <code>InspectStorage</code>)</li> <li>MUST NOT contain business logic or behavior</li> <li>Self-contained with all required data for execution</li> </ul>"},{"location":"reference/contexts/","title":"Contexts","text":"<ul> <li>Provide dependency injection for Procedures and Policies</li> <li>Contain Emitters for output (events or commands)</li> <li>Contain Queriers for reading state</li> <li>MAY contain Mutators (for Policies only)</li> <li>Named with pattern: <code>{ProcedureName}Context</code> or <code>{PolicyName}Context</code></li> <li>Specific to each Procedure or Policy type</li> </ul>"},{"location":"reference/emitters/","title":"Emitters","text":"<ul> <li>Provide methods for emitting Events (from Procedures) or Commands (from Policies)</li> <li>Named with pattern: <code>{ProcedureName}Emitters</code> or <code>{PolicyName}Emitters</code></li> <li>Each emitter method corresponds to a specific Event or Command type</li> <li>Methods have signature: <code>(payload: Event | Command) -&gt; None</code></li> <li>Injected into Contexts for use by Procedures and Policies</li> </ul>"},{"location":"reference/events/","title":"Events","text":"<ul> <li>Must described in past-tense</li> <li>Must be Immutable</li> <li>Should be self contained (all data required for representing some model state is contained in events)</li> <li>Ordered</li> </ul>"},{"location":"reference/models/","title":"Models","text":""},{"location":"reference/mutators/","title":"Mutators","text":"<ul> <li>Perform write operations</li> <li>CAN mutate state (event store, databases, filesystems, etc.)</li> <li>MUST NOT emit events or commands directly</li> <li>Have signature: <code>(input: MutationInput) -&gt; MutationResult</code></li> <li>Idempotent when possible</li> <li>CAN have side effects</li> <li>Return confirmation or status of the mutation</li> </ul>"},{"location":"reference/policies/","title":"Policies","text":"<ul> <li>Consume Events</li> <li>CAN emit Commands</li> <li>CAN query state (read-only)</li> <li>CAN mutate state (via mutations)</li> <li>Have signature: <code>(context: PolicyContext, event: Event) -&gt; None</code></li> <li>Stateless (all state via context or event)</li> <li>Contain business logic for reacting to events</li> </ul>"},{"location":"reference/procedures/","title":"Procedures","text":"<ul> <li>Consume Commands</li> <li>CAN emit Events</li> <li>CAN query state (read-only)</li> <li>MUST NOT mutate state</li> <li>Have signature: <code>(context: ProcedureContext, command: Command) -&gt; None</code></li> <li>Stateless (all state via context or command)</li> <li>Contain business logic for processing commands</li> </ul>"},{"location":"reference/queriers/","title":"Queriers","text":"<ul> <li>Perform read-only operations</li> <li>MUST NOT mutate state</li> <li>MUST NOT emit events or commands</li> <li>Have signature: <code>(input: QueryInput) -&gt; QueryResult</code></li> <li>Deterministic when possible</li> <li>CAN access external systems (databases, filesystems, APIs)</li> <li>Return serializable data structures</li> </ul>"}]}