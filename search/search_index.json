{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"getting dizzy","text":"<p>\u201cStart Where You Are. Use What You Have. Do What You Can.\u201d - Arthur Ashe</p> <p>\"Write drunk, edit sober\" -  some drunk who has never editted in their life</p> <p>We've ranted and rambled enough - let's get to work and test out some code.</p> <p>There isn't one particular goal with this project, this repository is meant to serve as a piece of living proof of failure and progress. We are engine building - bootstrapping a patradigm for processing that can survive shifting paradigms, requirements, domains, whim and fancy alike. It is the bastard child of many problems:</p> <ul> <li> <p>Contract work typically demands a new bespoke system be created every 1-3 years. This is fun - but not sustainable. What if we could carry over the largest least-interesting piece of technology every time to provide a backbone for developing and exploring new paradigms instead of re-inventing the wheel every time?</p> </li> <li> <p>Questions of which database are best suited for the user, what UI JS frontend is coolest, what programming language is most likely to provide job stability are tired. It should not matter what of these desicions we make now, because we are more likely to be wrong than right anyway. Therefor - we would be better equipped for these questions if we had an archuitecture that granted us the grace of making these mistakes and correcting them - rather than living with the pain of our ignorance forever.</p> </li> </ul> <p>Besides these burning problems - we also have a general burning desire that we share. Surely some things could be better.</p> <p>The architecture we build here is intended not to be the best - but to be as flexible as possible to the point we know longer care about what's best.</p>"},{"location":"#what-the-heck-is-this-for","title":"What the heck is this for","text":"<ul> <li>Running interruptable pipelines that can be resumed later<ul> <li>Let me write a quick script that will never be used for production workflows real quick...</li> </ul> </li> <li>Replacing Jupyter as a scientific processing tool to accelerate TRL<ul> <li>DAG's are everywhere and in-memory objects are not to be trusted</li> </ul> </li> <li>Meta-programming without DSL's or Monkey-patching<ul> <li>cool IaC bro, can I have a diagram?</li> </ul> </li> <li>The MO - Moving Objects<ul> <li>hey can you send me those vacation photos of me? thx &lt;3</li> </ul> </li> <li>???<ul> <li>do u got games on ur phone</li> </ul> </li> </ul>"},{"location":"#how-im-writing-this-document","title":"How I'm Writing This Document","text":"<p>There are two primary streams of new content I'm using to quide my hand in writting. Ramblings I've recorded from various sources - transcribed, timestamping, summarized, bulletized, re-ingesticized, mentalized and finally written and this lil table of content below.</p> <p>I'm not yet sure if I'll include source rambles - I don't think they matter all that much. I may include them for the hell of it later.</p>"},{"location":"#content","title":"Content:","text":"<ul> <li>Event Sourcing</li> <li>Command Query Responsability Seperation</li> <li>DDD<ul> <li>Entities and Value Objects</li> <li>Entity ID</li> </ul> </li> <li>Listeners and Callbacks</li> <li>Observer Pattern</li> <li>Event Loop</li> <li>Delaying Event Loop Effects</li> <li>Event Loops Emitting Events</li> <li>Event Sourcing Command Ledger ID -&gt; Entity ID</li> <li>Provenance, Fault Tolerance, Queue Rebuilding</li> <li>Automatic Magic with Python Types</li> <li>Entity Component Systems and Database Normalization</li> <li>Event Sourcing and Deterministic Lockstep</li> <li>Domain Driven Command Query Event Sourcing Queue</li> </ul> <p>Errata</p> <ul> <li>Listener Liskov Substitution Mypy Problems </li> <li>Discuss Semantics of <code>subscribe</code></li> </ul> <p>Links</p> <ul> <li>Build your own event system in Python</li> <li>Building Efficient Event-Driven ETL Processes on Google Cloud: Best Practices, Correlation ID Tracking and Testing</li> <li>Mentat</li> <li>https://www.cosmicpython.com/blog/2017-09-19-why-use-domain-events.html</li> <li>https://www.cosmicpython.com/</li> <li>https://blog.jannikwempe.com/domain-driven-design-entities-value-objects</li> <li>https://ogrady.github.io/jekyll/update/2021/12/17/entity-component-system.html</li> </ul> <p>Links - less relevant</p> <ul> <li>Rust's trait system is a proof engine, let's make it prove us an ABI! - Pierre Avital</li> </ul>"},{"location":"#event-sourcing","title":"Event Sourcing","text":""},{"location":"#listeners-and-callbacks","title":"Listeners and Callbacks","text":"<pre><code>class Listener:\n    def __init__(self):\n        self.callbacks = []\n\n    def add_listener(self, cb):\n        self.callbacks.append(cb)\n\n    def fire(self):\n        for cb in self.callbacks:\n            cb()\n</code></pre> <p>Example</p> <pre><code>def on_event():\n    print(\"Event has been fired!\")\n\ndef on_another_event():\n    print(\"Another event handler called.\")\n\nevent_listener = Listener()\n\nevent_listener.add_listener(on_event)\nevent_listener.add_listener(on_another_event)\n\nevent_listener.fire()\n</code></pre>"},{"location":"#observer-pattern","title":"Observer Pattern","text":"<pre><code>class Subject:\n    _state: int = None\n    _observers: List[Observer] = []\n\n    def attach(self, observer: Observer):\n        self._observers.append(observer)\n\n    def notify(self):\n        for observer in self._observers:\n            observer.update(self)\n\nclass ObserverA:\n    def update(self, subject: Subject) -&gt; None:\n        print(subject._state)\n</code></pre>"},{"location":"#event-loop","title":"Event Loop","text":"<p>Instead of 'Subjects' that notify observers, we have an <code>EventSystem</code> that passes <code>Events</code> to <code>Listners</code>.</p> <p>The <code>EventQueue</code> is used as an abstration on top of a list.  Note that the the <code>EventSystem</code> only provides a method for processing the <code>next</code> event, if the EventQurur were instead built with a construct that is thread-safe, we could make an event system that is naively parallizable.</p> <pre><code>class Listener(ABC):\n    def run(self, queue: EventQueue, event: Event):\n        pass\n\n@dataclass\nclass Event:\n    pass\n\nclass EventQueue:\n    def __init__(self):\n        self.items = []\n\n    def emit(self, item):\n        self.items.append(item)\n\n    def next(self):\n        return self.items.pop(0)\n\nclass EventSystem:\n    def __init__(self):\n        self.queue = EventQueue()\n\n    def register(self, event_type):\n        if event_type not in self.listeners\n            self.listeners[event_type] = []\n\n    def subscribe(self, event_type, listener: Listener):\n        self.register(event_type)\n        self.listeners[event_type].append(listener)\n\n    def next(self):\n        event = self.queue.next()\n        event_type = type(event)\n\n        for listener in self.listeners[event_type]:\n            listener.run(self.queue, event)\n</code></pre> <p>Criticisms: - Listeners shouldn't have full access to the queue - depending on the implementation a developer may cause damage via empty, or a sort, or a loop</p>"},{"location":"#delaying-event-loop-effects","title":"Delaying Event Loop Effects","text":"<p>We may want Event Loops to emit events in a way that allows for more fine grained control. By ensuring that the <code>EventQueue</code> is a proper interface that can be passed into <code>Listener</code>, we can add pre and post processing code that has some knowledge about inputs and outputs. </p> <pre><code>class EventSystem:\n    def __init__(self):\n        self.queue = EventQueue()\n\n    def register(self, event_type):\n        if event_type not in self.listeners\n            self.listeners[event_type] = []\n\n    def subscribe(self, event_type, listener: Listener):\n        self.register(event_type)\n        self.listeners[event_type].append(listener)\n\n    def next(self):\n        event = self.queue.next()\n        event_type = type(event)\n\n        for listener in self.listeners[event_type]:\n            vq = EventQueue()\n            # pre processing code...\n            listener.run(vq, event)\n            # post processing code...\n            for e in vq.items:\n                self.queue.emit(e)\n</code></pre>"},{"location":"#event-loops-emitting-events","title":"Event Loops Emitting Events","text":"Source code in <code>dizzy/event_loop_emitting.py</code> <pre><code>class EventSystem:\n\tdef __init__(self, meta_instrumentation = None):\n\t\tself.queue = EventQueue()\n\t\tself.listeners = {}\n\t\tself._meta_es = meta_instrumentation\n\n\tdef subscribe(self, event_type, listener: Listener):\n\t\tif event_type not in self.listeners:\n\t\t\tself.listeners[event_type] = []\n\n\t\tself.listeners[event_type].append(listener)\n\n\tdef _on(self, temp):\n\t\tif self._meta_es is not None:\n\t\t\tprint(temp)\n\n\tdef next(self):\n\t\tevent = self.queue.next()\n\t\tevent_type = type(event)\n\n\t\tfor listener in self.listeners[event_type]:\n\t\t\tvq = EventQueue()\n\n\t\t\tself._on(EventSystem.MetaActivityStarted('started'))\n\t\t\tlistener.run(vq, event)\n\t\t\tself._on(EventSystem.MetaActivityEnded('ended'))\n\n\t\t\tfor e in vq.items:\n\t\t\t\tself.queue.emit(e)\n\n\tdef run(self):\n\t\twhile not self.queue.empty():\n\t\t\tself.next()\n\n\t@dataclass\n\tclass MetaActivityStarted(Event):\n\t\tvalue: str\n\n\n\t@dataclass\n\tclass MetaActivityEnded(Event):\n\t\tvalue: str\n</code></pre> <p>The addition of <code>ActivityStarted</code> and <code>ActivityEnded</code> shows how even arbitray classes can have domain events encoded inside; signifiying that the events are dependendant on this specific implementation. Though, the implementation just prints the events back out for now</p> <pre><code>$ python dizzy/event_loop_emitting.py \nExampleEvent(value='Hello World!')\nEventSystem.MetaActivityStarted(value='started')\nHello World!\nEventSystem.MetaActivityEnded(value='ended')\n</code></pre> <p>I imagined a pattern like this - but realized now that it's been coded that if <code>self._on</code> is something like</p> <pre><code>def _on(self, event: Event):\n    if self._meta_es is not None:\n        self._meta_es.queue.emit(event)\n</code></pre> <p>then doing something like</p> <pre><code>...\nactivity_id = self._on(EventSystem.ActivityStarted('started', datetime.now()))\nlistener.run(vq, event)\nself._on(EventSystem.ActivityEnded('ended', activity_id, datetime.now()))\n...\n</code></pre> <p>maybe isn't well supported...</p> <p>I supposed that ID's could be gleaned from the Event Queue - that when storing into the Event Store we simply auto increment an ID and return it to use as an Entity ID in situations like this. However - the auto-increment is  1. not a good solution for decentralized distributed systems,  2. could lead to confusion because <code>ActivityEnded</code> would also generate it's own ID and  3. deeply couples this particular provenance solution to the events being generated (I may want to strip these <code>self._on</code> calls and remove the inner meta <code>EventSystem</code> and rely on good-ol-fashion callbacks here)</p> <p>So what's the alternative here? We have to construct the Activity ID prior to emitting events. I ranted a little bit about why I didn't want to do this - but I am feeling now that this was the wrong direction to take.</p> <p>I suppose the true issue with Entity ID's being passed around manually is one of permissions. We don't want a user to just pick any arbitrary Entity ID and attach meaningless Events to it - so this issue will need to be revisited.</p> <p>Pushing ahead, I went and created a basic command system that consume the raw events (without storing them into an Event Store) to explore how this would be problematic.</p> Source code in <code>dizzy/domain/event_system.py</code> <pre><code>class ProvenanceDuckDBQueryModel:\n    def __init__(self, conn):\n        self.conn = conn\n\n    def get_activity(self, activity_id: ActivityID) -&gt; dict:\n        cursor = self.conn.cursor()\n        cursor.execute('''\n            SELECT * FROM activities WHERE activity_id = ?\n        ''', (activity_id,))\n        row = cursor.fetchone()\n        return {\n            \"activity_id\": row[0],\n            \"start_time\": datetime.fromisoformat(row[1]),\n            \"end_time\": datetime.fromisoformat(row[2]) if row[2] else None\n        } if row else None\n\n    def all_activity(self) -&gt; dict:\n        self.conn.sql('SELECT * FROM activities;').show()\n</code></pre> <p>               Bases: <code>dizzy.domain.event_system.Listener</code></p> Source code in <code>dizzy/domain/event_system.py</code> <pre><code>class ProvenanceDuckDBListener(Listener):\n    def __init__(self, conn):\n        self.conn = conn\n        self._init_db()\n\n    def _init_db(self):\n        self.conn.sql('''\n            CREATE TABLE IF NOT EXISTS activities (\n                activity_id TEXT PRIMARY KEY,\n                start_time TIMESTAMP,\n                end_time TIMESTAMP\n            )\n        ''')\n\n        self.conn.sql(\"\"\"\n            CREATE SEQUENCE IF NOT EXISTS seq_activity_id START 1;\n        \"\"\")\n\n    def run(self, queue, event):\n        pass\n</code></pre> <p>               Bases: <code>dizzy.domain.event_system.ProvenanceDuckDBListener</code></p> Source code in <code>dizzy/domain/event_system.py</code> <pre><code>class HandleStarted(ProvenanceDuckDBListener):\n    def run(self, queue, event: EventSystem.ActivityStarted):\n        self.conn.sql('''\n            INSERT INTO activities (activity_id, start_time)\n            VALUES ((nextval('seq_activity_id'), ?)\n        ''', (event.start_time.isoformat()))\n</code></pre> <p>               Bases: <code>dizzy.domain.event_system.ProvenanceDuckDBListener</code></p> Source code in <code>dizzy/domain/event_system.py</code> <pre><code>class HandleEnded(ProvenanceDuckDBListener):\n    def run(self, queue, event: EventSystem.ActivityEnded):\n        self.conn.sql('''\n            UPDATE activities \n            SET end_time = ?\n            WHERE activity_id = ?\n        ''', (event.end_time.isoformat(), event.activity_id))\n</code></pre> <p>How would it look to have some Activity/Entity Manager thing that can delegate Activity ID's to us?</p> <p>After doing a bit more research - it appears this is just how things need to be with Event Sourcing.</p> <p>There are a few possible solutions to Entity ID's that are client-generated to avoid the problem of not being able to use sequential integers.</p> <ul> <li>Snowflake IDs: timestamp, machine ID, sequence number</li> <li>Hash Based ID: still needs something like a timestamp or some pseudorandom element</li> <li>UUID / KSUID / ULID</li> </ul>"},{"location":"#on-entity-ids-in-decentralized-systems","title":"On Entity IDs in Decentralized Systems","text":"<p>This particular aside will need to be made significantly longer at some point.</p> <p>In a decentralized system where trust is minimal, it may be the case that some Agents are restricted in terms of what entities can be created or modified. Additionally, it is important to correctly attribute Entities with the Agents that created them so that such permisions can be managed in the first place.</p> <p>Cryptographic Keys and Signatures could be a solution.</p> <p>For entities - since the Entity ID must be generated prior to attaching a type or any other events, an Agent could create a new public/private keypair and use this to derive the Entity ID.</p>"},{"location":"#unsorted","title":"Unsorted","text":"<p>It would be slick if we could define our Events and Entities together</p> <pre><code>class Provenance:\n    # Entities that Exist\n    Entity: DomainEntity\n    Activity: DomainEntity\n\n    # Value objects?\n    ...\n\n    # Entity Properties\n    Activity.Started\n    Activity.Ended\n\n    # Relationships\n    Activity used Entity\n    Entity was_derived_from Entity\n</code></pre>"},{"location":"#errata","title":"Errata","text":""},{"location":"#listener-liskov-substitution-mypy-problems","title":"Listener Liskov Substitution Mypy Problems","text":"<p>Corrected? <pre><code>from abc import ABC, abstractmethod\nfrom typing import TypeVar, Generic\n\nT = TypeVar('T', bound=Event)\nclass Listener(ABC, Generic[T]):\n    @abstractmethod\n    def run(self, queue, event: T):\n        pass\n\nclass MyListener(Listener[BuiltRaw]):\n    def run(self, queue, event: BuiltRaw):\n        pass # ...\n</code></pre></p>"},{"location":"#discuss-semantics-of-subscribe","title":"Discuss: Semantics of <code>subscribe</code>","text":"<p>Typically I have the <code>subscribe</code> method take a type, and <code>Listener</code> class as parameters. In the <code>Listener</code> class is a <code>run</code> method which is invoked my the system. Should we instead be using <code>MyListener.run</code> instead? That is - should we pass the function pointer directly instead of the class?</p> <p>I want to lean my answer to whatever is easier to implement in C... I know passing continuations or lambda expressions is probably well supported in Rust, but for whatever reason it feels important to be able to capture the behavior in C also...</p> <p>I'm still burdened by the enchanting idea of code generation (or, just behind-the-scene execution) of subscriptions based on types. C doesn't have types - so there is no advantage there.</p>"}]}